<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mezclador de Colores Automotrices</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      body { background: #fafafa }
      .shadow-card { box-shadow: 0 10px 20px rgba(0,0,0,.06), 0 2px 6px rgba(0,0,0,.04); }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-presets="env,react">
const { useMemo, useState, useRef, useEffect } = React;

/* ===================== UTILIDADES DE COLOR ===================== */
function srgbToLinear(c){ c=c/255; return c<=0.04045? c/12.92 : Math.pow((c+0.055)/1.055,2.4); }
function linearToSrgb(c){ const v = c<=0.0031308? 12.92*c : 1.055*Math.pow(c,1/2.4)-0.055; return Math.min(255, Math.max(0, Math.round(v*255))); }
function rgbToXyz([r,g,b]){ const R=srgbToLinear(r), G=srgbToLinear(g), B=srgbToLinear(b);
  const X=0.4124564*R+0.3575761*G+0.1804375*B, Y=0.2126729*R+0.7151522*G+0.072175*B, Z=0.0193339*R+0.119192*G+0.9503041*B; return [X,Y,Z]; }
function xyzToLab([X,Y,Z]){ const Xn=0.95047, Yn=1, Zn=1.08883; const fx=f(X/Xn), fy=f(Y/Yn), fz=f(Z/Zn);
  return [116*fy-16, 500*(fx-fy), 200*(fy-fz)];
  function f(t){ const e = Math.pow(6/29,3), k = 1/(3*Math.pow(6/29,2)); return t>e? Math.cbrt(t) : k*t + 4/29; }
}
function labToXyz([L,a,b]){ const Yn=1, Xn=0.95047, Zn=1.08883;
  const fy=(L+16)/116, fx=fy+a/500, fz=fy-b/200;
  const e = Math.pow(6/29,3), k = 1/(3*Math.pow(6/29,2));
  const xr = fx**3>e? fx**3 : (116*fx-16)/903.3;
  const yr = L>8? fy**3 : L/903.3;
  const zr = fz**3>e? fz**3 : (116*fz-16)/903.3;
  return [xr*Xn, yr*Yn, zr*Zn];
}
function xyzToRgb([X,Y,Z]){ let R=3.2404542*X-1.5371385*Y-0.4985314*Z, G=-0.969266*X+1.8760108*Y+0.041556*Z, B=0.0556434*X-0.2040259*Y+1.0572252*Z;
  return [linearToSrgb(R), linearToSrgb(G), linearToSrgb(B)]; }
function hexToRgb(hex){ const m=/^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(hex.trim()); if(!m) return [0,0,0];
  return [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16)]; }
function rgbToHex([r,g,b]){ const to2=n=>Math.round(n).toString(16).padStart(2,"0"); return `#${to2(r)}${to2(g)}${to2(b)}`.toUpperCase(); }
function deltaE76(l1,l2){ return Math.sqrt((l1[0]-l2[0])**2+(l1[1]-l2[1])**2+(l1[2]-l2[2])**2); }
function deltaE2000(lab1, lab2){
  const [L1,a1,b1]=lab1,[L2,a2,b2]=lab2;
  const avgLp=(L1+L2)/2, C1=Math.sqrt(a1*a1+b1*b1), C2=Math.sqrt(a2*a2+b2*b2), avgC=(C1+C2)/2;
  const G=0.5*(1-Math.sqrt(Math.pow(avgC,7)/(Math.pow(avgC,7)+Math.pow(25,7))));
  const a1p=(1+G)*a1, a2p=(1+G)*a2, C1p=Math.sqrt(a1p*a1p+b1*b1), C2p=Math.sqrt(a2p*a2p+b2*b2), avgCp=(C1p+C2p)/2;
  const h1p=Math.atan2(b1,a1p)*180/Math.PI + (Math.atan2(b1,a1p)<0?360:0);
  const h2p=Math.atan2(b2,a2p)*180/Math.PI + (Math.atan2(b2,a2p)<0?360:0);
  let deltahp=0; if(C1p*C2p===0){deltahp=0;} else if(Math.abs(h2p-h1p)<=180){deltahp=h2p-h1p;} else {deltahp=h2p<=h1p?h2p-h1p+360:h2p-h1p-360;}
  const deltaLp=L2-L1, deltaCp=C2p-C1p, deltaHp=2*Math.sqrt(C1p*C2p)*Math.sin((deltahp*Math.PI/180)/2);
  const avgHp=(Math.abs(h1p-h2p)>180)?(h1p+h2p+360)/2:(h1p+h2p)/2;
  const T=1-0.17*Math.cos((avgHp-30)*Math.PI/180)+0.24*Math.cos((2*avgHp)*Math.PI/180)+0.32*Math.cos((3*avgHp+6)*Math.PI/180)-0.20*Math.cos((4*avgHp-63)*Math.PI/180);
  const Sl=1+(0.015*Math.pow(avgLp-50,2))/Math.sqrt(20+Math.pow(avgLp-50,2)), Sc=1+0.045*avgCp, Sh=1+0.015*avgCp*T;
  const Rt=-2*Math.sqrt(Math.pow(avgCp,7)/(Math.pow(avgCp,7)+Math.pow(25,7)))*Math.sin((60*Math.exp(-Math.pow((avgHp-275)/25,2)))*Math.PI/180);
  return Math.sqrt(Math.pow(deltaLp/Sl,2)+Math.pow(deltaCp/Sc,2)+Math.pow(deltaHp/Sh,2)+Rt*(deltaCp/Sc)*(deltaHp/Sh));
}
const rgbToLinearArr = rgb => [srgbToLinear(rgb[0]), srgbToLinear(rgb[1]), srgbToLinear(rgb[2])];
const linearToSrgbArr = arr => [linearToSrgb(arr[0]), linearToSrgb(arr[1]), linearToSrgb(arr[2])];
function mixLinearRGB(basesLinear, w){ let r=0,g=0,b=0; for(let i=0;i<basesLinear.length;i++){ r+=basesLinear[i][0]*w[i]; g+=basesLinear[i][1]*w[i]; b+=basesLinear[i][2]*w[i]; } return [r,g,b]; }
function projectOntoSimplex(w){ const n=w.length,u=[...w].sort((a,b)=>b-a); let cssv=0,rho=0; for(let i=0;i<n;i++){ cssv+=u[i]; if(u[i]+(1-cssv)/(i+1)>0) rho=i+1; } const theta=(1-u.slice(0,rho).reduce((a,b)=>a+b,0))/rho; return w.map(v=>Math.max(0,v+theta)); }
function projectBoundedSimplex(w,L,U){ const n=w.length; let x=w.map((wi,i)=>Math.min(U[i],Math.max(L[i],wi))); let sum=x.reduce((a,b)=>a+b,0), iter=0;
  while(Math.abs(sum-1)>1e-10 && iter++<50){ const free=[]; for(let i=0;i<n;i++){ const atL=Math.abs(x[i]-L[i])<1e-12, atU=Math.abs(x[i]-U[i])<1e-12; if(!atL && !atU) free.push(i); }
    if(!free.length) break; const d=(1-sum)/free.length; for(const i of free){ x[i]=Math.min(U[i],Math.max(L[i],x[i]+d)); } sum=x.reduce((a,b)=>a+b,0);
  }
  if(Math.abs(sum-1)>1e-6){ const totalRange=U.reduce((acc,ui,i)=>acc+(ui-L[i]),0); if(totalRange>0){ const Lsum=L.reduce((a,b)=>a+b,0); x=x.map((_,i)=>L[i]+(U[i]-L[i])*((1-Lsum)/totalRange)); } }
  return x;
}
function roundKeepSum(values, res=0.1){ const un=values.slice(); const rd=un.map(v=>Math.round(v/res)*res);
  const diff=un.reduce((a,b)=>a+b,0)-rd.reduce((a,b)=>a+b,0); const steps=Math.round(diff/res); if(steps===0) return rd;
  const residues=un.map((v,i)=>({i, r:(v/res)-Math.round(v/res)})).sort((a,b)=>Math.abs(b.r)-Math.abs(a.r));
  let s=steps; for(let k=0;k<residues.length && s!==0;k++){ const idx=residues[k].i; rd[idx]+=Math.sign(steps)*res; s-=Math.sign(steps); }
  return rd;
}

/* ===================== DATOS BASE ===================== */
const DEFAULT_BASES = [
  { id:"BLANCO",  hex:"#FFFFFF", densidad:1.35, min:0,   max:1    },
  { id:"NEGRO",   hex:"#000000", densidad:1.10, min:0,   max:0.08 },
  { id:"AMARILLO",hex:"#FFD200", densidad:1.10, min:0,   max:1    },
  { id:"ROJO",    hex:"#C1272D", densidad:1.12, min:0,   max:1    },
  { id:"AZUL",    hex:"#0057B7", densidad:1.10, min:0,   max:1    },
  { id:"VERDE",   hex:"#1BAA6C", densidad:1.10, min:0,   max:1    },
  { id:"NARANJA", hex:"#FF6A00", densidad:1.10, min:0,   max:1    },
  { id:"VIOLETA", hex:"#7F3FBF", densidad:1.12, min:0,   max:1    },
  { id:"ALUMINIO",hex:"#B5B8BA", densidad:1.30, min:0,   max:0.20 },
  { id:"PERLA",   hex:"#EAE4D7", densidad:1.25, min:0,   max:0.20 },
];

const CSV_TEMPLATE = `Marca,Modelo,Año,Código,Variante,L*,a*,b*,Observaciones
TOYOTA,Corolla,2018,1F7,Classic Silver,76.2,-1.1,0.5,Ejemplo aproximado
HONDA,Civic,2020,NH-797M,Modern Steel,48.9,0.6,-2.8,Ejemplo aproximado
`;

/* ===================== APP ===================== */
function App(){
  const [tab, setTab] = useState("codigo"); // mezcla | codigo | lab | foto
  const [bases, setBases] = useState(DEFAULT_BASES);
  const [unidad, setUnidad] = useState("g");
  const [totalLote, setTotalLote] = useState(100);
  const [usarDE2000, setUsarDE2000] = useState(true);
  const [resRedondeo, setResRedondeo] = useState(0.1);

  // Objetivo centralizado en L*a*b*
  const [objetivoLab, setObjetivoLab] = useState(()=> xyzToLab(rgbToXyz(hexToRgb("#1F3A93"))));
  const objetivoHex = useMemo(()=> rgbToHex(xyzToRgb(labToXyz(objetivoLab))), [objetivoLab]);
  const [hexInput, setHexInput] = useState(objetivoHex);
  useEffect(()=> setHexInput(objetivoHex), [objetivoHex]);

  // Catálogo OEM (+ alta rápida)
  const [catalogo, setCatalogo] = useState([]);
  const [filtroCodigo, setFiltroCodigo] = useState("");
  const inputCSVRef = useRef(null);
  const [resultados, setResultados] = useState([]);
  const [mensajeBusqueda, setMensajeBusqueda] = useState("");
  const [nuevo, setNuevo] = useState({ marca:"", modelo:"", anio:"", codigo:"", variante:"", L:"", a:"", b:"", obs:"" });

  // Mezcla
  const [pesos, setPesos] = useState(()=> Array(DEFAULT_BASES.length).fill(1/DEFAULT_BASES.length));
  const [sol, setSol] = useState(null);

  // Foto (beta)
  const [fotoURL, setFotoURL] = useState(null);
  const [pts, setPts] = useState([]); // [negro, gris, blanco, muestra]
  const canvasRef = useRef(null);
  const imgRef = useRef(null);

  const basesRgb = useMemo(()=> bases.map(b=>hexToRgb(b.hex)), [bases]);
  const basesLinear = useMemo(()=> basesRgb.map(rgbToLinearArr), [basesRgb]);
  const errorColor = (a,b)=> usarDE2000? deltaE2000(a,b) : deltaE76(a,b);

  function optimizar(){
    const n=bases.length; let w=projectOntoSimplex([...pesos]);
    const Lb=bases.map(b=>Math.max(0,b.min??0));
    const Ub=bases.map(b=>Math.min(1,b.max??1));
    const maxIter=1500; let step=0.5, bestW=[...w], bestErr=Infinity;
    const tLab = objetivoLab;

    const errFor = (wv)=>{
      const mixLin = mixLinearRGB(basesLinear, wv);
      const mixRgb = linearToSrgbArr(mixLin);
      const mixLab = xyzToLab(rgbToXyz(mixRgb));
      return errorColor(tLab, mixLab);
    };

    w = projectBoundedSimplex(w, Lb, Ub);

    for(let it=0; it<maxIter; it++){
      const Bw = mixLinearRGB(basesLinear, w);
      const t   = labToXyz(tLab);
      const tRgb= xyzToRgb(t);
      const tLin= rgbToLinearArr(tRgb);

      const grad = new Array(n).fill(0);
      for(let i=0;i<n;i++){
        const bi=basesLinear[i];
        grad[i]=2*( bi[0]*(Bw[0]-tLin[0]) + bi[1]*(Bw[1]-tLin[1]) + bi[2]*(Bw[2]-tLin[2]) );
      }
      let wNew = w.map((wi,i)=> wi - step*grad[i]);
      wNew = projectBoundedSimplex(wNew, Lb, Ub);

      const eNew = errFor(wNew), eOld = errFor(w);
      if(eNew < eOld){ w=wNew; step*=1.02; } else { step*=0.5; }
      if(eNew < bestErr){ bestErr=eNew; bestW=[...wNew]; }
      if(step < 1e-5) break;
    }

    setPesos(bestW);
    const mixLin = mixLinearRGB(basesLinear, bestW);
    const mixRgb = linearToSrgbArr(mixLin);
    const labMix = xyzToLab(rgbToXyz(mixRgb));
    const mixHex = rgbToHex(mixRgb);
    setSol({ pesos:bestW, deltaE:errorColor(tLab,labMix), mixHex, mixRgb, mixLab:labMix });
  }

  const gramos = useMemo(()=> (unidad==="g"? pesos.map(w=>w*totalLote) : pesos.map((w,i)=> w*totalLote*(bases[i].densidad||1))), [pesos,totalLote,unidad,bases]);
  const gramosRedondeados = useMemo(()=> roundKeepSum(gramos, resRedondeo), [gramos, resRedondeo]);
  const totalG = useMemo(()=> gramosRedondeados.reduce((a,b)=>a+b,0), [gramosRedondeados]);
  const previewMix = sol?.mixHex || "#CCCCCC";

  function exportarFormulaCSV(){
    const encabezado=["#","Tinta","HEX","Densidad(g/ml)", unidad==="g"?"Gramos":"Gramos (desde ml)","%"];
    const filas=bases.map((b,i)=>[i+1,b.id,b.hex,b.densidad??"", gramosRedondeados[i].toFixed(2), (pesos[i]*100).toFixed(2)]);
    const totalRow=["","TOTAL","","", totalG.toFixed(2), "100.00"];
    const csv=[encabezado,...filas,totalRow].map(r=>r.join(",")).join("\n");
    const blob=new Blob([csv],{type:"text/csv;charset=utf-8;"});
    const url=URL.createObjectURL(blob); const a=document.createElement("a"); a.href=url; a.download="formula_mezcla_automotriz.csv"; a.click(); URL.revokeObjectURL(url);
  }

  function descargarPlantillaCSV(){
    const blob=new Blob([CSV_TEMPLATE],{type:"text/csv;charset=utf-8;"}); const url=URL.createObjectURL(blob);
    const a=document.createElement("a"); a.href=url; a.download="catalogo_codigos_plantilla.csv"; a.click(); URL.revokeObjectURL(url);
  }

  function cargarCSV(evt){
    const file=evt.target.files?.[0]; if(!file) return;
    const reader=new FileReader();
    reader.onload=()=>{
      const text=reader.result.toString();
      const rows=text.split(/\r?\n/).filter(Boolean).map(r=>r.split(","));
      const head=rows.shift();
      const idx={ Marca:head.indexOf("Marca"), Modelo:head.indexOf("Modelo"), Año:head.indexOf("Año"), Código:head.indexOf("Código"), Variante:head.indexOf("Variante"), L:head.indexOf("L*"), a:head.indexOf("a*"), b:head.indexOf("b*"), Obs:head.indexOf("Observaciones") };
      const parsed=rows.map(r=>({ marca:r[idx.Marca]||"", modelo:r[idx.Modelo]||"", anio:r[idx.Año]||"", codigo:r[idx.Código]||"", variante:r[idx.Variante]||"", L:parseFloat(r[idx.L]||""), a:parseFloat(r[idx.a]||""), b:parseFloat(r[idx.b]||""), obs:r[idx.Obs]||"" }))
                       .filter(x=>!isNaN(x.L) && !isNaN(x.a) && !isNaN(x.b));
      setCatalogo(parsed); setMensajeBusqueda("Catálogo cargado: "+parsed.length+" códigos."); setResultados([]);
    };
    reader.readAsText(file);
  }

  function exportarCatalogoActual(){
    const header=["Marca","Modelo","Año","Código","Variante","L*","a*","b*","Observaciones"];
    const filas=catalogo.map(x=>[x.marca,x.modelo,x.anio,x.codigo,x.variante,x.L,x.a,x.b,x.obs||""]);
    const csv=[header,...filas].map(r=>r.join(",")).join("\n");
    const blob=new Blob([csv],{type:"text/csv;charset=utf-8;"}); const url=URL.createObjectURL(blob);
    const a=document.createElement("a"); a.href=url; a.download="catalogo_actualizado.csv"; a.click(); URL.revokeObjectURL(url);
  }

  function agregarNuevo(){
    if(!nuevo.codigo || !nuevo.marca){ alert("Al menos Código y Marca son obligatorios."); return; }
    const L=parseFloat(nuevo.L), a=parseFloat(nuevo.a), b=parseFloat(nuevo.b);
    if([L,a,b].some(v=>isNaN(v))){ alert("L*, a*, b* deben ser números."); return; }
    const entry={ marca:(nuevo.marca||"").toUpperCase(), modelo:nuevo.modelo||"", anio:nuevo.anio||"", codigo:(nuevo.codigo||"").toUpperCase(), variante:nuevo.variante||"", L,a,b, obs:nuevo.obs||"" };
    setCatalogo(prev=>{
      const exists=prev.some(x=>(x.marca+x.modelo+x.anio+x.codigo+x.variante).toUpperCase()===(entry.marca+entry.modelo+entry.anio+entry.codigo+entry.variante).toUpperCase());
      if(exists && !confirm("Este código ya existe con ese contexto. ¿Agregar de todos modos?")) return prev;
      return [entry, ...prev];
    });
    setNuevo({ marca:"", modelo:"", anio:"", codigo:"", variante:"", L:"", a:"", b:"", obs:"" });
    setMensajeBusqueda("Nuevo código agregado. Ahora puedes Exportar catálogo.");
  }

  function buscarCodigo(){
    if(!catalogo.length){ setMensajeBusqueda("Primero carga tu catálogo o agrega nuevos códigos."); setResultados([]); return; }
    const q=filtroCodigo.trim().toLowerCase(); if(!q){ setMensajeBusqueda("Escribe un código o marca/modelo y pulsa Buscar."); setResultados([]); return; }
    const hits=catalogo.filter(x=>(x.codigo+" "+x.marca+" "+x.modelo+" "+x.variante).toLowerCase().includes(q));
    if(hits.length===1){ const x=hits[0]; setObjetivoLab([x.L,x.a,x.b]); setMensajeBusqueda(`1 coincidencia: ${x.codigo} — usando L*a*b*`); setResultados([]); setTab("mezcla"); }
    else if(hits.length>1){ setMensajeBusqueda(`${hits.length} coincidencias. Haz clic en la fila correcta.`); setResultados(hits); }
    else { setMensajeBusqueda("Sin coincidencias. Verifica el código o amplía la búsqueda (marca/modelo)."); setResultados([]); }
  }

  /* ============ FOTO (beta) ============ */
  function drawPhoto(){
    const cvs=canvasRef.current, img=imgRef.current; if(!cvs||!img) return;
    const ctx=cvs.getContext("2d");
    const maxW=720, scale=Math.min(maxW/img.naturalWidth,1);
    const w=Math.round(img.naturalWidth*scale), h=Math.round(img.naturalHeight*scale);
    cvs.width=w; cvs.height=h; ctx.clearRect(0,0,w,h); ctx.drawImage(img,0,0,w,h);
    pts.forEach((p,i)=>{ ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fillStyle=["#000","#777","#fff","#0af"][i]||"#0af"; ctx.strokeStyle="#000"; ctx.lineWidth=1; ctx.fill(); ctx.stroke();
      ctx.font="12px sans-serif"; ctx.fillStyle="#000"; ctx.strokeStyle="#fff"; ctx.lineWidth=3; const labels=["NEGRO","GRIS","BLANCO","MUESTRA"];
      ctx.strokeText(labels[i]||"",p.x+8,p.y-8); ctx.fillText(labels[i]||"",p.x+8,p.y-8);
    });
  }
  useEffect(drawPhoto,[fotoURL,pts]);

  function avgAround(ctx,x,y,r=6){
    const x0=Math.max(0,Math.floor(x-r)), y0=Math.max(0,Math.floor(y-r));
    const x1=Math.min(ctx.canvas.width-1,Math.floor(x+r)), y1=Math.min(ctx.canvas.height-1,Math.floor(y+r));
    const w=x1-x0+1, h=y1-y0+1; const imgData=ctx.getImageData(x0,y0,w,h).data; let R=0,G=0,B=0,n=0;
    for(let i=0;i<imgData.length;i+=4){ R+=imgData[i]; G+=imgData[i+1]; B+=imgData[i+2]; n++; } return [R/n,G/n,B/n];
  }

  function computeFromPhoto(){
    if(!canvasRef.current || pts.length<4) return;
    const ctx=canvasRef.current.getContext("2d");
    const pBlack=avgAround(ctx,pts[0].x,pts[0].y), pGray=avgAround(ctx,pts[1].x,pts[1].y), pWhite=avgAround(ctx,pts[2].x,pts[2].y), pSam=avgAround(ctx,pts[3].x,pts[3].y);
    const scale=(v,b,w)=> (v-b)/Math.max(1,(w-b));
    let s=[ scale(pSam[0],pBlack[0],pWhite[0]), scale(pSam[1],pBlack[1],pWhite[1]), scale(pSam[2],pBlack[2],pWhite[2]) ];
    let g=[ scale(pGray[0],pBlack[0],pWhite[0]), scale(pGray[1],pBlack[1],pWhite[1]), scale(pGray[2],pBlack[2],pWhite[2]) ];
    const gMean=(g[0]+g[1]+g[2])/3, gains=[ gMean/(g[0]||1e-6), gMean/(g[1]||1e-6), gMean/(g[2]||1e-6) ];
    s=[ s[0]*gains[0], s[1]*gains[1], s[2]*gains[2] ];
    const srgb=s.map(v=>Math.max(0,Math.min(1,v))*255);
    const lab=xyzToLab(rgbToXyz(srgb));
    setObjetivoLab(lab); setTab("mezcla");
  }

  /* ===================== UI ===================== */
  return (
    <div className="min-h-screen text-neutral-800 p-6">
      <div className="max-w-7xl mx-auto space-y-4">
        <h1 className="text-2xl font-semibold">Mezclador de Colores Automotrices</h1>

        <div className="flex flex-wrap gap-2">
          <button onClick={()=>setTab("mezcla")} className={`px-4 py-2 rounded-xl border ${tab==="mezcla"?"bg-black text-white":""}`}>Mezcla directa</button>
          <button onClick={()=>setTab("codigo")} className={`px-4 py-2 rounded-xl border ${tab==="codigo"?"bg-black text-white":""}`}>Por código (OEM)</button>
          <button onClick={()=>setTab("lab")} className={`px-4 py-2 rounded-xl border ${tab==="lab"?"bg-black text-white":""}`}>Por medición (L*a*b*)</button>
          <button onClick={()=>setTab("foto")} className={`px-4 py-2 rounded-xl border ${tab==="foto"?"bg-black text-white":""}`}>Foto (beta)</button>
        </div>

        <div className="grid lg:grid-cols-3 gap-4">
          {/* Panel izquierdo */}
          <div className="bg-white rounded-2xl shadow-card p-4 space-y-3">
            {tab==="mezcla" && (
              <>
                <label className="text-sm font-medium">Color objetivo (HEX)</label>
                <div className="flex gap-3 items-center">
                  <input type="color" value={objetivoHex} onChange={(e)=> setObjetivoLab(xyzToLab(rgbToXyz(hexToRgb(e.target.value))))} className="w-12 h-10 rounded" />
                  <input value={hexInput} onChange={(e)=> setHexInput(e.target.value.toUpperCase())}
                         onBlur={()=>{ try{ setObjetivoLab(xyzToLab(rgbToXyz(hexToRgb(hexInput)))); }catch{} }}
                         onKeyDown={(e)=>{ if(e.key==='Enter'){ try{ setObjetivoLab(xyzToLab(rgbToXyz(hexToRgb(hexInput)))); }catch{} } }}
                         className="flex-1 border rounded px-3 py-2" />
                  <button onClick={optimizar} className="px-4 py-2 rounded-xl bg-black text-white">Calcular</button>
                </div>
              </>
            )}

            {tab==="codigo" && (
              <>
                <div className="flex gap-2 flex-wrap items-center">
                  <button className="px-3 py-2 rounded-xl border" onClick={descargarPlantillaCSV}>Descargar plantilla CSV</button>
                  <button className="px-3 py-2 rounded-xl border" onClick={()=> inputCSVRef.current?.click()}>Cargar catálogo (CSV)</button>
                  <input type="file" ref={inputCSVRef} className="hidden" accept=".csv" onChange={cargarCSV} />
                  <button className="px-3 py-2 rounded-xl border" onClick={exportarCatalogoActual}>Exportar catálogo</button>
                </div>

                <div className="mt-2 flex gap-2">
                  <input placeholder="Escribe código (1F7, NH-797M) o marca/modelo"
                         value={filtroCodigo}
                         onChange={e=>setFiltroCodigo(e.target.value)}
                         onKeyDown={e=>{ if(e.key==='Enter') buscarCodigo(); }}
                         className="flex-1 border rounded px-3 py-2" />
                  <button onClick={buscarCodigo} className="px-4 py-2 rounded-xl bg-black text-white">Buscar</button>
                </div>

                {mensajeBusqueda && <div className="text-xs mt-2 px-2 py-1 rounded bg-neutral-100">{mensajeBusqueda}</div>}

                {resultados.length>0 && (
                  <div className="max-h-56 overflow-auto border rounded mt-2">
                    <table className="w-full text-sm">
                      <thead><tr className="border-b text-left">
                        <th className="p-2">Marca</th><th className="p-2">Modelo</th><th className="p-2">Año</th>
                        <th className="p-2">Código</th><th className="p-2">Variante</th><th className="p-2">L*</th><th className="p-2">a*</th><th className="p-2">b*</th>
                      </tr></thead>
                      <tbody>
                        {resultados.map((x,i)=>(
                          <tr key={i} className="border-b hover:bg-neutral-50 cursor-pointer"
                              onClick={()=>{ setObjetivoLab([x.L,x.a,x.b]); setTab("mezcla"); }}>
                            <td className="p-2">{x.marca}</td><td className="p-2">{x.modelo}</td><td className="p-2">{x.anio}</td>
                            <td className="p-2 font-mono">{x.codigo}</td><td className="p-2">{x.variante}</td>
                            <td className="p-2">{x.L}</td><td className="p-2">{x.a}</td><td className="p-2">{x.b}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )}

                <div className="mt-4 p-3 border rounded-2xl bg-neutral-50">
                  <div className="font-medium mb-2">+ Agregar nuevo código</div>
                  <div className="grid md:grid-cols-3 gap-2">
                    <input placeholder="Marca *" value={nuevo.marca} onChange={e=>setNuevo({...nuevo,marca:e.target.value})} className="border rounded px-3 py-2" />
                    <input placeholder="Modelo" value={nuevo.modelo} onChange={e=>setNuevo({...nuevo,modelo:e.target.value})} className="border rounded px-3 py-2" />
                    <input placeholder="Año" value={nuevo.anio} onChange={e=>setNuevo({...nuevo,anio:e.target.value})} className="border rounded px-3 py-2" />
                    <input placeholder="Código *" value={nuevo.codigo} onChange={e=>setNuevo({...nuevo,codigo:e.target.value})} className="border rounded px-3 py-2" />
                    <input placeholder="Variante" value={nuevo.variante} onChange={e=>setNuevo({...nuevo,variante:e.target.value})} className="border rounded px-3 py-2" />
                    <input placeholder="L*" value={nuevo.L} onChange={e=>setNuevo({...nuevo,L:e.target.value})} className="border rounded px-3 py-2" />
                    <input placeholder="a*" value={nuevo.a} onChange={e=>setNuevo({...nuevo,a:e.target.value})} className="border rounded px-3 py-2" />
                    <input placeholder="b*" value={nuevo.b} onChange={e=>setNuevo({...nuevo,b:e.target.value})} className="border rounded px-3 py-2" />
                    <input placeholder="Observaciones" value={nuevo.obs} onChange={e=>setNuevo({...nuevo,obs:e.target.value})} className="border rounded px-3 py-2 md:col-span-3" />
                  </div>
                  <div className="flex gap-2 mt-2">
                    <button className="px-4 py-2 rounded-xl bg-black text-white" onClick={agregarNuevo}>Guardar en memoria</button>
                    <button className="px-4 py-2 rounded-xl border" onClick={exportarCatalogoActual}>Descargar CSV actualizado</button>
                  </div>
                  <div className="text-xs opacity-70 mt-1">* Recomendado: ingresa L*a*b* desde espectro o usa pestaña Foto (beta) y luego copia.</div>
                </div>
              </>
            )}

            {tab==="lab" && (
              <>
                <label className="text-sm font-medium">Ingresar L* a* b*</label>
                <div className="grid grid-cols-3 gap-2">
                  <input type="number" step="0.1" placeholder="L*" value={objetivoLab?.[0]??""}
                         onChange={e=>setObjetivoLab([parseFloat(e.target.value)||0, objetivoLab?.[1]??0, objetivoLab?.[2]??0])}
                         className="border rounded px-3 py-2" />
                  <input type="number" step="0.1" placeholder="a*" value={objetivoLab?.[1]??""}
                         onChange={e=>setObjetivoLab([objetivoLab?.[0]??0, parseFloat(e.target.value)||0, objetivoLab?.[2]??0])}
                         className="border rounded px-3 py-2" />
                  <input type="number" step="0.1" placeholder="b*" value={objetivoLab?.[2]??""}
                         onChange={e=>setObjetivoLab([objetivoLab?.[0]??0, objetivoLab?.[1]??0, parseFloat(e.target.value)||0])}
                         className="border rounded px-3 py-2" />
                </div>
                <div className="flex gap-3 items-center">
                  <button onClick={()=>{ setTab("mezcla"); optimizar(); }} className="px-4 py-2 rounded-xl bg-black text-white">Usar y calcular</button>
                </div>
                <div className="text-xs opacity-70">Tip: pega L*a*b* desde un espectrofotómetro para máxima precisión.</div>
              </>
            )}

            {tab==="foto" && (
              <>
                <div className="space-y-2">
                  <div className="text-sm font-medium">Cargar foto (tapadera + carta)</div>
                  <input type="file" accept="image/*" onChange={e=>{ const f=e.target.files?.[0]; if(!f) return; const url=URL.createObjectURL(f); setFotoURL(url); setPts([]); }} />
                  {fotoURL && (
                    <div className="space-y-2">
                      <div className="text-xs opacity-70">Clic en orden: <b>NEGRO</b>, <b>GRIS</b>, <b>BLANCO</b>, <b>MUESTRA</b>.</div>
                      <img ref={imgRef} src={fotoURL} alt="foto" onLoad={drawPhoto} className="hidden" />
                      <canvas ref={canvasRef} className="w-full max-w-[720px] rounded border"
                        onClick={e=>{ const rect=e.currentTarget.getBoundingClientRect();
                          const x=(e.clientX-rect.left)*(e.currentTarget.width/rect.width);
                          const y=(e.clientY-rect.top)*(e.currentTarget.height/rect.height);
                          setPts(p=> p.length>=4? p : [...p,{x,y}]); }} />
                      <div className="flex gap-2">
                        <button className="px-3 py-2 rounded-xl border" onClick={()=>setPts([])}>Reiniciar puntos</button>
                        <button disabled={pts.length<4} className={`px-3 py-2 rounded-xl ${pts.length<4?"bg-neutral-200":"bg-black text-white"}`} onClick={computeFromPhoto}>Calcular L*a*b* y usar</button>
                      </div>
                    </div>
                  )}
                  {!fotoURL && <div className="text-xs opacity-70">Tip: usa la carta gris 18% cuando ilumines la tapadera.</div>}
                </div>
              </>
            )}
          </div>

          {/* Panel resultado */}
          <div className="bg-white rounded-2xl shadow-card p-4 space-y-3">
            <div className="flex items-center justify-between">
              <span className="text-sm font-medium">Resultado</span>
              {sol && <span className="text-xs px-2 py-1 rounded bg-neutral-100">ΔE ≈ {sol.deltaE.toFixed(2)} {usarDE2000?"(DE2000)":"(DE76)"}</span>}
            </div>
            <div className="grid grid-cols-2 gap-3">
              <div className="rounded-xl border overflow-hidden">
                <div className="p-3 text-xs">Objetivo</div>
                <div className="h-20" style={{background: objetivoHex}} />
                <div className="p-3 text-xs font-mono">{`L${objetivoLab[0].toFixed(1)} a${objetivoLab[1].toFixed(1)} b${objetivoLab[2].toFixed(1)}`}</div>
              </div>
              <div className="rounded-xl border overflow-hidden">
                <div className="p-3 text-xs">Mezcla</div>
                <div className="h-20" style={{background: previewMix}} />
                <div className="p-3 text-xs font-mono">{previewMix}</div>
              </div>
            </div>
            <div className="flex items-center gap-3">
              <label className="text-sm">ΔE</label>
              <select value={usarDE2000?"de2000":"de76"} onChange={e=>setUsarDE2000(e.target.value==="de2000")} className="border rounded px-2 py-1">
                <option value="de2000">DE2000 (recomendado)</option>
                <option value="de76">DE76</option>
              </select>
            </div>
          </div>

          {/* Lote y export de fórmula */}
          <div className="bg-white rounded-2xl shadow-card p-4 space-y-3">
            <div className="flex items-center gap-3">
              <label className="text-sm font-medium">Lote</label>
              <input type="number" min={1} step={1} value={totalLote} onChange={e=>setTotalLote(parseFloat(e.target.value||"0"))} className="w-28 border rounded px-3 py-2" />
              <select value={unidad} onChange={e=>setUnidad(e.target.value)} className="border rounded px-2 py-2">
                <option value="g">gramos</option>
                <option value="ml">mililitros</option>
              </select>
              <label className="text-sm ml-2">Redondeo</label>
              <select value={resRedondeo} onChange={e=>setResRedondeo(parseFloat(e.target.value))} className="border rounded px-2 py-2">
                <option value={0.1}>0.1 g</option>
                <option value={0.5}>0.5 g</option>
                <option value={1}>1 g</option>
              </select>
              <button onClick={exportarFormulaCSV} className="ml-auto px-4 py-2 rounded-xl border">Exportar CSV de fórmula</button>
            </div>
            <div className="text-xs opacity-70">El redondeo mantiene la suma total exacta con método de restos mayores.</div>
          </div>
        </div>

        {/* Tabla de bases */}
        <div className="bg-white rounded-2xl shadow-card p-4">
          <div className="flex items-center justify-between mb-2">
            <h2 className="font-medium">Tintas base (con límites %)</h2>
            <div className="flex gap-2">
              <button className="px-3 py-2 rounded-xl border" onClick={()=> setPesos(Array(bases.length).fill(1/bases.length))}>Reiniciar %</button>
              <button className="px-3 py-2 rounded-xl bg-black text-white" onClick={optimizar}>Recalcular</button>
            </div>
          </div>
          <div className="overflow-auto">
            <table className="w-full text-sm">
              <thead><tr className="text-left border-b">
                <th className="py-2">#</th><th className="py-2">Tinta</th><th className="py-2">Color</th><th className="py-2">HEX</th><th className="py-2">Densidad</th><th className="py-2">Min %</th><th className="py-2">Max %</th><th className="py-2">% Mezcla</th><th className="py-2">Gramos</th>
              </tr></thead>
              <tbody>
                {bases.map((b,i)=>(
                  <tr key={i} className="border-b last:border-b-0">
                    <td className="py-2 pr-2">{i+1}</td>
                    <td className="py-2 pr-2"><input value={b.id} onChange={e=> setBases(bs=> bs.map((x,k)=> k===i? {...x,id:e.target.value}:x))} className="border rounded px-2 py-1 w-40"/></td>
                    <td className="py-2 pr-2"><input type="color" value={b.hex} onChange={e=> setBases(bs=> bs.map((x,k)=> k===i? {...x,hex:e.target.value}:x))}/></td>
                    <td className="py-2 pr-2"><input value={b.hex} onChange={e=> setBases(bs=> bs.map((x,k)=> k===i? {...x,hex:e.target.value}:x))} className="border rounded px-2 py-1 font-mono w-28"/></td>
                    <td className="py-2 pr-2"><input type="number" step="0.01" value={b.densidad} onChange={e=> setBases(bs=> bs.map((x,k)=> k===i? {...x,densidad:parseFloat(e.target.value||"0")}:x))} className="border rounded px-2 py-1 w-24"/></td>
                    <td className="py-2 pr-2"><input type="number" step="0.01" value={((b.min??0)*100).toFixed(2)} onChange={e=> setBases(bs=> bs.map((x,k)=> k===i? {...x,min:Math.max(0,parseFloat(e.target.value||"0")/100)}:x))} className="border rounded px-2 py-1 w-20"/></td>
                    <td className="py-2 pr-2"><input type="number" step="0.01" value={((b.max??1)*100).toFixed(2)} onChange={e=> setBases(bs=> bs.map((x,k)=> k===i? {...x,max:Math.min(1,parseFloat(e.target.value||"0")/100)}:x))} className="border rounded px-2 py-1 w-20"/></td>
                    <td className="py-2 pr-2"><input type="number" step="0.01" value={(pesos[i]*100).toFixed(2)} onChange={e=>{ const p=Math.max(0,parseFloat(e.target.value||"0")/100); const np=[...pesos]; np[i]=p; setPesos(projectBoundedSimplex(np, bases.map(b=>b.min??0), bases.map(b=>b.max??1))); }} className="border rounded px-2 py-1 w-24"/></td>
                    <td className="py-2 pr-2 font-mono">{gramosRedondeados[i]?.toFixed(2)}</td>
                  </tr>
                ))}
              </tbody>
              <tfoot>
                <tr><td colSpan="8" className="py-2 text-right font-medium">Total (g)</td><td className="py-2 font-mono">{totalG.toFixed(2)}</td></tr>
              </tfoot>
            </table>
          </div>
          <div className="mt-3 text-xs opacity-70">Consejos: limita NEGRO/ALUMINIO/PERLA, usa ΔE2000 y evita reflejos al medir/cargar foto.</div>
        </div>
      </div>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
    </script>
  </body>
</html>
